aus afl++ entstanden
- rust library
- korpus(testcase), target und objectives
- comile guided anleitung für fuzzer
- erzeugt coverage und metriken
- feedback loop der test cases anhand von objectives in fehler und warnings sortiert
- mutators verändern input, evolutionärer ansatz UND zufällige werte
- analyzer: treffe aussagen über inputs treffen
- stages: baut pipeline auf
- executor: kombiniert input, observer und porgamm (inkl hardware support)
- ideal: programm direkt über memory parameter fuzzbar
### beispiel xpdf
- cve von 2019
- infinite recursion bug
- fix: recursion limit und fehler schmeissen
- feedback: coverage, runtime und stack size
- rust macht beim build alles.
	- **baut xpdf** mit bestimmter instrumentierung (spezifischer clang und gcc)
	- **starting sample** input: 2 pdfs ("hello world" und "example pdf")
		- -> corpus schreiben
		- in.-memory corpus contained die pdfs
	- **findings** on disc corpus contained findings
	- **observer** greift mittels shared memory auf fuzzingtarget 
		- time observer (laufzeit)
		- edge observer (coverage)
	- **objectives** timeout UND neue code pfade
	- **monitor**  printed wie viele targets
	- **forkserver** forked für jede execution und startet xpdf und füge datei als cmdl argument hinzu
	- timeout wert sinnvoll wählen ("wie lange läuft das tool?")
	- havoc mutator: sehr random, kommt von haus aus mit
- invalides pdf: als guter fall, weil das programm ja eigentlich läuft
- wie viele execs pro sekunde?
- schneller machen:
	- multicore
	- mehr sinnvoller input
	- kein fork&exec sondern direkt in memory 
	- lto compiler