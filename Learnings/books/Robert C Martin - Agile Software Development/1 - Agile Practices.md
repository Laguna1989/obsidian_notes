## Agile practices

* Processes to avoid Desaster Projects. But Processes cause the Desaster they try to avoid
    * Can even slow the Team to Miss Deadlines and Slip Budgets
    * Runaway-Process-Inflation
* The agile manifesto (2001)
    * Individuals and interactions over Processes and Tools
    * Working Software over comprehensive documentation
        * Producer No document until its need is immediate and signifikant
    * Customer collaboration over contract negotiation
    * Responding to Change over following a plan
* 12 Agile principles
    * Our highest priority is to satisfy the customer through early an continuous Delivery of valuable Software.
        * Delivery early and often
    * Welcome changing requirements, even late in development
    * Delivery working Software frequently
    * Business people and devlopers must Work together Daily throughout the Project
    * Build Projects around motivated individuals. Give them the Environment, Support and Tools they need.
    * The Most effective and efficient Methode of conveying information is face-to-face conversation
    * Working Software ist the primary measure of Progress
    * Agile Processes promote sustainable development
    * Continuous attention to technical excellence and good Design enhances agility.
    * Simplicity, the Art of maximizing the amount of work Not done, is Essential
    * The best architectures, requirements and Designs emerge from self-organizing teams
    * At regular Intervals the Team reflects on how to become more effective and adjusts.

## Overview of Extreme Programming XP

* The practices of [[Kent Beck - Extreme Programming Explained]]
    * Customer Team member
    * User Stories
    * Short cycles
    * Acceptance Tests
    * Pair Programming
    * Test Drive Development
    * Collective ownership
    * Continuous Integration
        * Build and Test end to end, including all acceptance tests
    * Sustainable pace
        * No overtime except for Last week in a Release
    * Open workspace
    * Planning Game
    * Simple Design
        * Consider the simplest Thing that could possibly Work
        * You are Not going to need it (Database, multiple Users, multithreading, …)
        * Once and only once (don't repeat yourself)
    * Refactoring
        * best done frequently
    * Metaphors


## Planning

* Initial Exploration
* Spülung, Splitting and Velocity
* Release planning
* Iteration planning
* Task Planning
    * Measure of "perfect Programming hours"
    * How does the Number of Points increase If the Team grows?
* Iteration
    * Evaluate Look, feel and Performance
## Testing

* Tests First means that the Software ist conveniently callable
* Tests First forces us to decouple the software
* Writing Test before Code improves our Designs
* Unit Test are White Box Tests, which verify the individual mechanisms of the system
* Acceptance tests are black Box Tests which verify that the customer requirements are met. They are written by the customer or someone close to the customer.